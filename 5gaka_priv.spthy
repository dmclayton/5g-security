theory 5gaka
begin

builtins: hashing

rule create_ue:
		let
			suci = h(~supi)
		in
		[Fr(~supi),Fr(~K)]
	--[AssignUserID($ue, ~K)]->
		[!UE_Identity($ue, suci, ~supi, $hn), !LongTermKey($ue, ~K), Out(suci), Out($hn)]

rule create_seaf:
		[Fr(~snid)]
	-->
		[!SEAF_Identity($seaf, ~snid)]

rule create_ausf:
		[]
	-->
		[!AUSF_Identity($ausf)]

rule create_arpf:
		[]
	-->
		[!ARPF_Identity($arpf)]

rule assoc_ue_hn:
		[!UE_Identity($ue, suci, ~supi, $hn), !LongTermKey($ue, ~K), !ARPF_Identity($arpf)]
	--[KeyReveal($arpf, $ue, ~K)]->
		[!ARPF_Store_Info($arpf, $ue, ~supi, ~K)]

rule N1_message:
        [!UE_Identity($ue, suci, ~supi, $hn), !SEAF_Identity($seaf, ~snid)]
    --[SendN1($ue, $seaf)]->
    	[Out(<'N1_message', $ue, $seaf, suci, $hn>)]

rule receive_N1_message:
        [!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), In(<'N1_message', $ue, $seaf, suci, $hn>)]
    -->
       	[Nausf_UEAuthentication_Authenticate_Request($seaf, $ausf, suci, $hn, ~snid)]

rule receive_Nausf_UEAuthentication_Authenticate:
        [!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), !ARPF_Identity($arpf), Nausf_UEAuthentication_Authenticate_Request($seaf, $ausf, suci, $hn, ~snid)]
    -->
    	[Ndm_UEAuthentication_GET_Request($ausf, $arpf, suci, ~snid)]

rule receive_Ndm_UEAuthentication_GET_Request:
		let
			xres_star = h(~K, ~snid, ~rand)
			k_ausf = h(~K, ~snid)
		in
        [Fr(~rand), !ARPF_Identity($arpf), !ARPF_Store_Info($arpf, $ue, ~supi, ~K), !UE_Identity($ue, suci, ~supi, $hn), Ndm_UEAuthentication_GET_Request($ausf, $arpf, suci, ~snid)]
    -->
    	[Ndm_UEAuthentication_GET_Response($arpf, $ausf, ~rand, ~supi, xres_star, k_ausf)]

rule nausf_response:
		let
			hxres_star = h(~rand, xres_star)
			k_seaf = h(k_ausf, ~snid)
		in
		[!AUSF_Identity($ausf), !SEAF_Identity($seaf, ~snid), Ndm_UEAuthentication_GET_Response($arpf, $ausf, ~rand, ~supi, xres_star, k_ausf)]
	--[StoreXRES($ausf, xres_star, hxres_star)]->
		[StoredXRES($ausf, xres_star, hxres_star), Nausf_UEAthentication_Authenticate_Response($ausf, $seaf, ~rand, hxres_star, k_seaf)]

rule auth_request:
		[!SEAF_Identity($seaf, ~snid), !UE_Identity($ue, suci, ~supi, $hn), Nausf_UEAthentication_Authenticate_Response($ausf, $seaf, ~rand, hxres_star, k_seaf)]
	-->
		[Out(<'Authentication_Request', $seaf, ~snid, $ue, ~rand>)]

rule auth_response:
		let
			res_star = h(~K, ~snid, ~rand)
		in
		[!UE_Identity($ue, suci, ~supi, $hn), !ARPF_Store_Info($arpf, $ue, ~supi, ~K), !SEAF_Identity($seaf, ~snid), In(<'Authentication_Request', $seaf, ~snid, $ue, ~rand>)]
	--[AuthResponse($ue, $seaf, $arpf)]->
		[Out(<'Authentication_Response', $seaf, ~snid, $ue, ~supi, res_star, ~rand>)]

rule nausf_request:
		let
			hres_star = h(~rand, res_star)
		in
		[!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), StoredXRES($ausf, xres_star, hres_star), In(<'Authentication_Response', $seaf, ~snid, $ue, ~supi, res_star, ~rand>)]
	--[NausfRequest($ue, $seaf, $ausf)]->
		[StoredRES($ausf, hres_star), Nausf_UEAuthentication_Authenticate_Request(res_star, ~supi, $seaf, ~snid, $arpf)]

rule nausf_final_response:
		[!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), StoredRES($ausf, hres_star), Nausf_UEAuthentication_Authenticate_Request(res_star, ~supi, $seaf, ~snid, $arpf)]
	--[AuthSuccess($seaf, $ausf)]->
		[Nausf_UEAuthentication_Authenticate_Response(~supi, $seaf, ~snid, $ausf)]

lemma Valid_setup:
	exists-trace
	" Ex ue seaf ausf #i #j.
		  SendN1(ue, seaf) @ #i
		& NausfRequest(ue, seaf, ausf) @ #j
		& #i < #j
	"

lemma Valid_setup_full:
	exists-trace
	" Ex ue seaf ausf #i #j.
		  SendN1(ue, seaf) @ #i
		& AuthSuccess(seaf, ausf) @ #j
		& #i < #j
	"

lemma Client_auth_priv:
	" All ue seaf ausf #i #j.
		(SendN1(ue, seaf) @ #i
		& AuthSuccess(seaf, ausf) @ #j)
		==>
		(Ex arpf k #r. KeyReveal(arpf, ue, k) @ #r)
	"

end