theory 5gaka
begin

builtins: hashing

rule create_ue:
		[Fr(~suci),Fr(~K)]
	--[AssignUserID($ue, ~K)]->
		[!UE_Identity($ue, ~suci, $supi, $hn), !LongTermKey($ue, ~K), Out(~suci), Out($hn)]

rule create_seaf:
		[Fr(~snid)]
	-->
		[!SEAF_Identity($seaf, ~snid)]

rule create_ausf:
		[]
	-->
		[!AUSF_Identity($ausf)]

rule create_arpf:
		[]
	-->
		[!ARPF_Identity($arpf)]

rule key_reveal:
		[!LongTermKey($ue, ~K), !ARPF_Identity($arpf)]
	--[KeyReveal($arpf, $ue, ~K)]->
		[!ARPF_Store_Key($arpf, $ue, ~K)]

rule N1_message:
        [!UE_Identity($ue, ~suci, $supi, $hn), !SEAF_Identity($seaf, ~snid)]
    --[SendN1($ue, $seaf)]->
    	[Out(<'N1_message', $ue, $seaf, ~suci, $hn>)]

rule receive_N1_message:
        [!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), In(<'N1_message', $ue, $seaf, ~suci, $hn>)]
    -->
       	[Out(<'Nausf_UEAuthentication_Authenticate_Request', $seaf, $ausf, ~suci, $hn, ~snid>)]

rule receive_Nausf_UEAuthentication_Authenticate:
        [!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), In(<'Nausf_UEAuthentication_Authenticate_Request', $seaf, $ausf, ~suci, $hn, ~snid>)]
    -->
    	[Out(<'Ndm_UEAuthentication_GET_Request', $ausf, $arpf, ~suci, ~snid>)]

rule receive_Ndm_UEAuthentication_GET_Request:
		let
			xres_star = h(~snid, ~rand, ~xres)
			k_ausf = h(~K)
		in
        [Fr(~rand), Fr(~xres), !ARPF_Identity($arpf), !ARPF_Store_Key($arpf, $ue, ~K), !UE_Identity($ue, ~suci, $supi, $hn), In(<'Ndm_UEAuthentication_GET_Request', $ausf, $arpf, ~suci, ~snid>), Fr(~rand)]
    -->
    	[Out(<'Ndm_UEAuthentication_GET_Response', $arpf, $ausf, ~rand, $supi, xres_star, k_ausf>)]

rule nausf_response:
		let
			hxres_star = h(~rand, xres_star)
			k_seaf = h(~snid, ~k_ausf)
		in
		[!AUSF_Identity($ausf), !SEAF_Identity($seaf, ~snid), In(<'Ndm_UEAuthentication_GET_Response', $arpf, $ausf, ~rand, $supi, xres_star, ~k_ausf>)]
	-->
		[StoredXRES($ausf, xres_star, hxres_star), Out(<'Nausf_UEAthentication_Authenticate_Response', $ausf, $seaf, ~rand, hxres_star, k_seaf>)]

rule auth_request:
		[!SEAF_Identity($seaf, ~snid), !UE_Identity($ue, ~suci, $supi, $hn), In(<'Nausf_UEAthentication_Authenticate_Response', $ausf, $seaf, ~rand, hxres, k_seaf>)]
	-->
		[Out(<'Authentication_Request', $seaf, ~snid, $ue, ~rand>)]

rule auth_response:
		let
			k_ausf = h(~K)
			k_seaf = h(~snid, ~k_ausf)
			res_star = h(~snid, ~rand, ~xres)
		in
		[Fr(~xres), !UE_Identity($ue, ~suci, $supi, $hn), !ARPF_Store_Key($arpf, $ue, ~K), !SEAF_Identity($seaf, ~snid), In(<'Authentication_Request', $seaf, ~snid, $ue, ~rand>)]
	-->
		[Out(<'Authentication_Response', $seaf, ~snid, $ue, $supi, res_star, ~rand>)]

rule nausf_request:
		let
			hres_star = h(~rand, res_star)
		in
		[!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), StoredXRES($ausf, $xres_star, hres_star), In(<'Authentication_Response', $seaf, ~snid, $ue, $supi, res_star, ~rand>)]
	-->
		[StoredRES($ausf, hres_star), Out(<'Nausf_UEAuthentication_Authenticate_Request', res_star, $supi, $seaf, ~snid, $arpf>)]

rule nausf_final_response:
		[!SEAF_Identity($seaf, ~snid), !AUSF_Identity($ausf), StoredRES($ausf, res_star), In(<'Nausf_UEAuthentication_Authenticate_Request', res_star, $supi, $seaf, ~snid, $ausf>)]
	--[AuthSuccess($seaf, $ausf)]->
		[Out(<'Nausf_UEAuthentication_Authenticate_Response', $supi, $seaf, ~snid, $ausf>)]

lemma Valid_setup:
	exists-trace
	" Ex ue seaf ausf #i #j.
		  SendN1(ue, seaf) @ #i
		& AuthSuccess(seaf, ausf) @ #j
		& #i < #j
	"

lemma Client_auth:
	" All ue seaf ausf #i #j.
		(SendN1(ue, seaf) @ #i
		& AuthSuccess(seaf, ausf) @ #j)
		==>
		(Ex arpf k #r. KeyReveal(arpf, ue, k) @ #r)
	"

end
